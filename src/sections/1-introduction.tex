\section{Introduction}

As argued by \citet{Accattoli19}, ``the $\lambda$-calculus is as old as computer science''; still, it remains relevant subject of study due to its far-reaching applications in both theory and practice.
For the same reason, the (untyped) $\lambda$-calculus is commonly taught in (under)graduate computer science programs at universities around the world.

A key stumbling block of learning and implementing the $\lambda$-calculus, is \emph{capture avoiding substitution}.
The issue is illustrated by the following term:
\begin{equation}
  (\lambda f .\, \lambda y .\, (f\ 1) + y)\ (\lambda z .\, \underbrace{y}_{\mathclap{\text{occurs free}}})\ 2
  \label{eq0}
\end{equation}
This term is \emph{not} reducible to a number value since the underbraced $y$ is a free variable; i.e., a variable that is not bound by an enclosing $\lambda$ term.
However, a na\"{i}ve, non capture avoiding substitution strategy could cause $f$ to be wrongly substituted to yield a reduct where $y$ is captured, such as $(\lambda y .\, ((\lambda z .\, {\color{red}{y}})\ 1) + y)\ 2$ which \emph{is} reducible to $4$.

Following, e.g., \citet{curry1958combinatory}, \citet{Plotkin75}, or \citet{DBLP:books/daglib/0067558}, the common technique to avoid such name capture is to rename variables during substitution.
Using renaming, the substitution of $f$ in \cref{eq0} instead yields the correct reduct $(\lambda r .\, ((\lambda z .\, y)\ 1) + r)\ 2$.

However, implementing renaming in a \emph{definitional interpreter}~\citep{reynolds98definitional} is a delicate and error-prone matter.
For this reason, and since the need for renaming is only relevant for terms that contain \emph{free variables}, educational texts---and many research papers---often define substitution only for \emph{closed} terms; i.e., terms that do not contain free variables.
But for some applications, such as implementing dependent type checking~\citep{Pareto1995ALF}, it can be desirable to reduce $\lambda$ terms involving free variables.

There exists alternative techniques that can be used to define (lazy) capture avoiding substitution, such as \emph{closures and environments}~\citep{Landin64}, \emph{de Bruijn indices}~\citep{de_Bruijn_1972}, and \emph{explicit substitutions}~\citep{AbadiCCL91}.
But naive and eager substitution functions are usually for teaching the $\lambda$-calculus, because they provide an intuitive framework for understanding the concept that the aforementioned techniques encode.

In recent years, Eelco Visser and I have been teaching the $\lambda$-calculus to bachelor students by having them implement definitional interpreters using a technique for capture avoiding substitution that avoids the need to rename bound variables.
The idea is to distinguish those terms in abstract syntax trees (ASTs) that have already been computed to normal forms, and to never substitute inside of those terms.
The benefit of this approach is that it makes it as simple to understand and implement substitutions for \emph{open} terms (i.e., terms that may contain free variables) as it is for closed terms.

The idea of distinguishing values from plain terms is not new (for example, \emph{reduction semantics}~\citep{FelleisenH92} commonly make this distinction), but I am not aware of this idea being applied to implement capture avoiding substitution functions outside of our course.\footnote{This judgement is made solely by the author of the present paper. I never had the chance to discuss the novelty of the technique with Eelco, in spite of us coming up with the idea of using the technique in the course together on Eelco's whiteboard.}
This paper presents the technique, and proves that the resulting substitution functions are capture avoiding.
We make the following technical contributions:

\begin{itemize}
\item We present a technique (\cref{sec:interpretation}) for capture avoiding substitution that does not require renaming, and that is about as simple to understand and implement as substitution functions for closed terms.
\item We present an intrinsically capture avoiding definitional interpreter (\cref{sec:normalization}) for the untyped $\lambda$-calculus which proves that the technique is, indeed, capture avoiding.
\end{itemize}





%%% Local Variables:
%%% reftex-default-bibliography: ("../references.bib")
%%% End:
